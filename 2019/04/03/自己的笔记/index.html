<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>自己的笔记 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JavaScript的作用域全局变量：如果这个声明变量是用var进行声明的，那么这个变量就是全局变量。注意以下： 1.全局变量在任何地方都可以调用。 2.全局变量只要不关闭客户端就会一直存在，占用内存。 3.全局变量是不能被删除的 4.除了函数以内定义的变量都是全局变量 5.全局变量可以作用在任何位置，作用的位置叫做作用域 局部变量：在函数体内声明的变量就是局部变量，在函数体外无法调用。局部变量只">
<meta property="og:type" content="article">
<meta property="og:title" content="自己的笔记">
<meta property="og:url" content="http://yoursite.com/2019/04/03/自己的笔记/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JavaScript的作用域全局变量：如果这个声明变量是用var进行声明的，那么这个变量就是全局变量。注意以下： 1.全局变量在任何地方都可以调用。 2.全局变量只要不关闭客户端就会一直存在，占用内存。 3.全局变量是不能被删除的 4.除了函数以内定义的变量都是全局变量 5.全局变量可以作用在任何位置，作用的位置叫做作用域 局部变量：在函数体内声明的变量就是局部变量，在函数体外无法调用。局部变量只">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-04-03T02:55:43.611Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="自己的笔记">
<meta name="twitter:description" content="JavaScript的作用域全局变量：如果这个声明变量是用var进行声明的，那么这个变量就是全局变量。注意以下： 1.全局变量在任何地方都可以调用。 2.全局变量只要不关闭客户端就会一直存在，占用内存。 3.全局变量是不能被删除的 4.除了函数以内定义的变量都是全局变量 5.全局变量可以作用在任何位置，作用的位置叫做作用域 局部变量：在函数体内声明的变量就是局部变量，在函数体外无法调用。局部变量只">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-自己的笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/03/自己的笔记/" class="article-date">
  <time datetime="2019-04-03T02:54:10.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      自己的笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JavaScript的作用域"><a href="#JavaScript的作用域" class="headerlink" title="JavaScript的作用域"></a>JavaScript的作用域</h1><p>全局变量：如果这个声明变量是用var进行声明的，那么这个变量就是全局变量。注意以下：</p>
<p>1.全局变量在任何地方都可以调用。</p>
<p>2.全局变量只要不关闭客户端就会一直存在，占用内存。</p>
<p>3.全局变量是不能被删除的</p>
<p>4.除了函数以内定义的变量都是全局变量</p>
<p>5.全局变量可以作用在任何位置，作用的位置叫做作用域</p>
<p>局部变量：在函数体内声明的变量就是局部变量，在函数体外无法调用。局部变量只能作用在花括号内，只作用在这一片，这一片是局部变量的作用域。</p>
<p>隐式全局变量：声明的变量没有var就叫做隐式全局变量。隐式全局变量是可以通过delete进行删除的。</p>
<h1 id="javaScript的作用域链"><a href="#javaScript的作用域链" class="headerlink" title="javaScript的作用域链"></a>javaScript的作用域链</h1><p>作用域可以嵌套使用，在嵌套过程中，如果不调用则没有值，如果多个嵌套函数同时调用，以标准流的形式来执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            f4();</span><br><span class="line">        &#125;</span><br><span class="line">        f3();</span><br><span class="line">    &#125;</span><br><span class="line">    f2();</span><br><span class="line">&#125;f1();</span><br></pre></td></tr></table></figure>
<p>在一个函数使用一个变量，先在该函数体内进行搜索，如果搜索不到则向外面继续寻找这个变量，一直到找到全局作用域，如果最终没有找到，则会报underfined。</p>
<h1 id="javaScript预解析"><a href="#javaScript预解析" class="headerlink" title="javaScript预解析"></a>javaScript预解析</h1><p>  javaSCript代码的执行是由浏览器的解析器来执行的，javaScript解析器在执行代码的时候，分为两个过程：预解析和代码执行过程</p>
<p> 预解析过程：</p>
<p>1.把变量的声明提升到当前作用域的最前面，只会提升变量，不会提升赋值。</p>
<p>2.把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。</p>
<p>3.先提升var 再提升function 。</p>
<p>4.隐式全局变量是可以通过预解析来进行访问的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f1();</span><br><span class="line">   <span class="built_in">console</span>.log(c);<span class="comment">//9</span></span><br><span class="line">   <span class="built_in">console</span>.log(b);<span class="comment">//9</span></span><br><span class="line">   <span class="built_in">console</span>.log(a);<span class="comment">//报错</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> a=b=c=<span class="number">9</span>;</span><br><span class="line">       <span class="built_in">console</span>.log(a);<span class="comment">//9</span></span><br><span class="line">       <span class="built_in">console</span>.log(b);<span class="comment">//9</span></span><br><span class="line">       <span class="built_in">console</span>.log(c);<span class="comment">//9</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上图代码中上面第三个a报错的原因是因为在函数中进行了声明，所以它变成了局部变量，而预解析可以访问隐式全局变量，但是不能访问局部变量所以结果为报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f1();</span><br><span class="line"> <span class="keyword">var</span> f1=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(num)</span><br><span class="line">     <span class="keyword">var</span> num=<span class="number">10</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面的案例中var f1只是一种假象，在面试的过程中会有这样的题目来挖坑，这样的预解析是错误的，是无法调用的方法。</p>
<p>作业：百度MDN去查找Date string Array的方法。</p>
<h1 id="代码的重复利用（函数）"><a href="#代码的重复利用（函数）" class="headerlink" title="代码的重复利用（函数）"></a>代码的重复利用（函数）</h1><p>函数的参数：</p>
<p>1.形参：函数定义的时候，函数后面小括号的变量叫做形参</p>
<p>2.实参：函数调用的时候，函数后面的小括号的变量叫做实参</p>
<p>返回值：</p>
<p>函数中油return，函数有返回值</p>
<p>函数中没有return，函数没有返回值，</p>
<p>函数没有明确返回值：函数中没有return 或者return后面没有任何内容。</p>
<p>如果一个函数中没有明确的返回值接受这个函数，结果是underfined</p>
<p>函数又分为：</p>
<p>1.无参数五返回值的函数</p>
<p>2.无参数有返回值的函数</p>
<p>3.有参数无返回值的函数</p>
<p>4.有参数有返回值的函数</p>
<p>arguments—-&gt;可以获取函数调用时，传入的实参个数</p>
<p>arguments是一个对象，是一个伪数组</p>
<p>arguments.length—-&gt;是实参的个数</p>
<p>arguments[索引]——-&gt;实参的值</p>
<h1 id="关于tab选项卡的总结（用js做）"><a href="#关于tab选项卡的总结（用js做）" class="headerlink" title="关于tab选项卡的总结（用js做）"></a>关于tab选项卡的总结（用js做）</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//获取大盒子的元素</span></span><br><span class="line">    <span class="keyword">var</span> odiv=<span class="built_in">document</span>.getElementById(<span class="string">'tabControl'</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//获取按钮的元素</span></span><br><span class="line">    <span class="keyword">var</span> btn=odiv.getElementsByTagName(<span class="string">'input'</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//获取类名为coder的子盒子，注意在使用classname时，需要注意是否是多类名元素</span></span><br><span class="line">    <span class="keyword">var</span> coder=<span class="built_in">document</span>.getElementsByClassName(<span class="string">'coder'</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//遍历按钮，并且给按钮添加一个index的样式，index是层叠样式，js通过这个来判断元素在哪一层</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;btn.length;i++)&#123;</span><br><span class="line">        btn[i].index=i;</span><br><span class="line">     </span><br><span class="line">       <span class="comment">//在鼠标经过按钮的时候给按钮修改类名，类名是提前做好的样式</span></span><br><span class="line">        btn[i].onmousemove=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         </span><br><span class="line">           <span class="comment">//在鼠标离开按钮的时候清除样式并把下面的盒子样式改变</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;btn.length;i++)&#123;</span><br><span class="line">                btn[i].className=<span class="string">""</span>;</span><br><span class="line">                coder[i].style.display=<span class="string">'none'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            <span class="comment">//使用this绑定btn的类名，使鼠标经过按钮的时候，为btn添加一个类名，并改变下面盒子的样式。</span></span><br><span class="line">            <span class="keyword">this</span>.className=<span class="string">"controlBin"</span>;</span><br><span class="line">            coder[<span class="keyword">this</span>.index].style.display=<span class="string">'block'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在使用这个函数体的时候，需要格外注意，按钮的数量必须与下方的盒子一致，否则报错。</span></span><br><span class="line"><span class="comment">//样式属于字符串的类型，所以我们在改变其样式的时候，需要加上单引号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意子盒子的宽高要与其他盒子一致，否则页面效果不理想，会跳动。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">轮播图的概念与之相近，可以在函数体中加上时钟使它自行跳动。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">开发过程中需要额外注意结构问题，避免在后期加特效的时候耗费时间，影响效率。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>使用js来做tab选项卡的好处相比较css 省去很长的代码以及烦心的定位问题，使我们的精力放在解决问题上，对于js获取元素的方法有以下几种方式，总结一下，避免日后因为这样的问题困扰：</p>
<p>1.通过id获取目标元素（document.getElementById(‘元素id名’)）</p>
<p>2.通过类名获取目标元素（getElementsByClassName(‘元素的类名’)）  注意这个有兼容性的问题，ie7以下的不支持，尽量少用</p>
<p>3.通过标签的名字获取目标元素（getElementsByTagName(‘标签名称’)） 注意这个是标签的名称，不是类名，不要混淆</p>
<p>页面中的样式可以通过js控制css来做，在元素中如果没有获取正确的数据，容易被浏览器报错，所以在开发过程中如果遇到报错，可以用console.log()方法来查看控制台，如果控制台数据有误，那么元素是没有正常获取的，此时应该检查自己的代码是否正确，语法以及命名。</p>
<h1 id="javaScript-对象"><a href="#javaScript-对象" class="headerlink" title="javaScript 对象"></a>javaScript 对象</h1><p>1.javaScript是基于对象的一门语言，并不是真正面向对象的。</p>
<p>2.可以通过内构的函数来构造自己的对象。</p>
<p>3.对象是一个变量，它有自己的属性以及特点，同时也具有数组的特点，可以理解为拥有多个属性的一个变量。</p>
<h1 id="关于对象的特点"><a href="#关于对象的特点" class="headerlink" title="关于对象的特点"></a>关于对象的特点</h1><p>1.对象是一组无序的数组，是不能通过for循环的方式将对象遍历出来，但是可以通过for__in循环的方式来遍历</p>
<p>具体方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> 变量名 <span class="keyword">in</span> 对象名)</span><br></pre></td></tr></table></figure>
<p>其中我们在输出对象时，不能通过   .属性名的方式来显示出来，因为结果为underfind</p>
<h1 id="关于动画属性的总结"><a href="#关于动画属性的总结" class="headerlink" title="关于动画属性的总结"></a>关于动画属性的总结</h1><p>1.animation 复合属性，可以设置动画对象的八个属性进行连写，其中所必须的属性是动画的name值以及动画持续时间。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">animation-name:动画名称，由@keyframes定义的</span><br><span class="line">animation-duration：动画的持续时间</span><br><span class="line">animation-timing-function：动画的过渡类型    </span><br><span class="line">	匀速 linear</span><br><span class="line">	曲线 ease</span><br><span class="line">animation-delay：动画的延迟时间</span><br><span class="line">animation-iteration-count：动画的循环次数   默认值是1次，如果想无限循环的话可以设置infinite</span><br><span class="line">animation-direction：设置动画在循环中是否反向运动 </span><br><span class="line">	normal 默认值。动画按正常播放。  </span><br><span class="line">	reverse 动画反向播放。  </span><br><span class="line">	alternate 动画在奇数次（1、3、5...）正向播放，在偶数次（2、4、6...）反向播放。  </span><br><span class="line">	alternate-reverse 动画在奇数次（1、3、5...）反向播放，在偶数次（2、4、6...）正向播放。</span><br><span class="line">	initial 设置该属性为它的默认值。请参阅   </span><br><span class="line">	inherit 从父元素继承该属性 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">animation-fill-mode：设置动画时间之外的状态</span><br><span class="line">animattion-play-state:设置动画的状态。</span><br><span class="line">	默认值是runing 表示在运行中</span><br><span class="line">	暂停是paused   表示暂停</span><br><span class="line"></span><br><span class="line">@keyframes  用来定义一个动画，可以用from&#123;&#125;---to&#123;&#125;来定义动画的节点，也可以用百分比0%---100%来定义多个动画节点。</span><br></pre></td></tr></table></figure>
<h1 id="关于2D转换（transform）"><a href="#关于2D转换（transform）" class="headerlink" title="关于2D转换（transform）"></a>关于2D转换（transform）</h1><p>transform 的属性可以连写多个属性名，格式如：transform：属性1 属性2 属性3；</p>
<p>2D转换常用的属性：</p>
<ol>
<li>rotate();  设置目标的2D旋转，正值为顺时针，负值为逆时针,单位为 “deg”</li>
<li>translate(X,Y); 设置目标的平移，复合属性，小括号里面第一个值是X轴，第二个是Y轴,单位是px</li>
</ol>
<p>​       也可以单独设置translateX，translateY.</p>
<ol>
<li>skew 斜切、变形，用的较少，将目标进行斜切，单位是“deg”</li>
<li>scale   缩放目标单位是数字，表示目标缩放的倍数 ，如果写一个值代表XY轴同时缩放，若写了两个则分别代表xy。</li>
<li>transform-origin   改变2D转换的位置原点</li>
</ol>
<h1 id="3D转换（trasform的升级用法）"><a href="#3D转换（trasform的升级用法）" class="headerlink" title="3D转换（trasform的升级用法）"></a>3D转换（trasform的升级用法）</h1><p>1.perpective   透视的视距，单位是px，通常用于在父元素，使得子元素在2d转换的过程中有近大远小的效果</p>
<ol>
<li>transfoem-style: presever-3d; 把一个元素转换成立体的3d对象，默认值是flat</li>
<li>transform-rotateX,rotateY 分别代表一个元素的3d旋转方式，单位是“deg”；</li>
<li>transform-translatZ   代表着3d对象的Z轴方向进行平移，注意，这个和2d对象是 有区别的。</li>
<li>trasform：rotate3d(x,y,z);   定义对象的3d缩放，里面分别代表着x,y,z 的缩放倍数</li>
</ol>
<h1 id="移动端开发"><a href="#移动端开发" class="headerlink" title="移动端开发"></a>移动端开发</h1><p>移动端的开发主要针对于手持设备进行单独开发</p>
<p>优点：对于 手机等手持设备等支持较好，可以有很高的分辨率，可以等比例进行页面的缩放</p>
<p>缺点：pc端的支持不够好，在pc页面上容易失真模糊</p>
<p>移动端开发的要点：</p>
<p>​    1.宽度为百分比流式布局</p>
<p>​    2.高度写死</p>
<p>​    3.用两倍图进行开发，目的是为了更清晰的展示</p>
<h2 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h2><h5 id="1-max-width，min-weidth"><a href="#1-max-width，min-weidth" class="headerlink" title="1.max-width，min-weidth"></a>1.max-width，min-weidth</h5><p>​    用来设置最大和最小的宽度，通常用来设置包裹所有标签的父盒子</p>
<p>​    目的是在用户缩放时不至于页面崩塌，造成体验效果差。</p>
<h5 id="2-在移动端百分比布局中有以下布局："><a href="#2-在移动端百分比布局中有以下布局：" class="headerlink" title="2.在移动端百分比布局中有以下布局："></a>2.在移动端百分比布局中有以下布局：</h5><p>​    1.两边固定，中间按比例缩放</p>
<p>​    2.等分布局</p>
<p>​    3.左边或者右边固定，另一边等比例缩放。</p>
<h5 id="3-两倍图的概念："><a href="#3-两倍图的概念：" class="headerlink" title="3.两倍图的概念："></a>3.两倍图的概念：</h5><p>​    通常在移动端开发的过程中ui设计师会给我们大于移动端两倍或者三倍的素材，目的是为了让移动端的设备</p>
<p>​    能够看的更清晰，所以我们在开发过程中如果拿到这样的设计图应该第一时间把所有的尺寸缩小一半或是三分之一</p>
<p>​    否则页面的效果不理想。</p>
<h5 id="4-视口的概念-重要"><a href="#4-视口的概念-重要" class="headerlink" title="4.视口的概念(重要)"></a>4.视口的概念(重要)</h5><p>​    </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">问题：一个电脑上的网站，在手机端访问，效果是什么样的？</span><br><span class="line"></span><br><span class="line">iPhone5的设备宽度只有320px，一张宽度为640px的图片在手机端访问，显示的效果是什么？</span><br><span class="line"></span><br><span class="line">1. 在手机端，html的大小都是980px，为什么？</span><br><span class="line">这主要是历史原因导致的，因为在移动设备刚流行的时候，网站大多都是pc端的，pc端的页面宽度一般都比较大，移动设备的宽度比较小，如果pc端页面直接在移动端显示的话，页面就会错乱。为了解决这个问题，移动端html的大小直接就定死成了980px（因为早起的pc端网站版心就是980px居多）。</span><br><span class="line"></span><br><span class="line">2. 视口</span><br><span class="line">在pc端，html的大小默认是继承了浏览器的宽度，即浏览器多宽，html的大小就是多宽，但是在移动端，多出来了一个视口的概念（乔布斯）,视口说白了就是介于浏览器与html之间的一个东西，视口的宽度默认定死了980px，因此html的宽度默认就是980px，视口的特点是能够根据设备的宽度进行缩放。</span><br><span class="line"></span><br><span class="line">3. 视口设置。</span><br><span class="line">对于现在的移动端页面来说，视口默认为980px肯定不合适，因为设备宽度不够的话，视口会进行缩放，导致页面展示效果不好看。</span><br></pre></td></tr></table></figure>
<h5 id="5-视口参数设置"><a href="#5-视口参数设置" class="headerlink" title="5.视口参数设置"></a>5.视口参数设置</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//width 设置视口的宽度</span></span><br><span class="line"><span class="comment">//width=device-width   设置视口宽度为设备的宽度（常用）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//initial-scale 设置初始缩放比例</span></span><br><span class="line"><span class="comment">//initial-scale=1.0  表示不缩放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//user-scalable 设置是否允许用户缩放</span></span><br><span class="line"><span class="comment">//user-scalable=no  不允许用户缩放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//maximum-scale  设置允许的最大缩放比例</span></span><br><span class="line"><span class="comment">//maximum-scale=1.0  可以不设置，因为都禁止用户缩放了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//minimum-scale 设置允许最小缩放比</span></span><br><span class="line"><span class="comment">//minimum-scale=1.0  不设置，因为都禁用用户缩放了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//标准写法：</span></span><br><span class="line"><span class="comment">//快捷键：  meta:vp + tab键</span></span><br><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0"</span>&gt;</span><br></pre></td></tr></table></figure>
<h1 id="flex弹性布局"><a href="#flex弹性布局" class="headerlink" title="flex弹性布局"></a>flex弹性布局</h1><p>当给一个盒子设置了display：flex之后，这个盒子就有了主轴和侧轴的概念。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向</span><br><span class="line">侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向的</span><br><span class="line">方向：主轴默认是水平从左到到右</span><br></pre></td></tr></table></figure>
<h2 id="1-flex-direction"><a href="#1-flex-direction" class="headerlink" title="1.flex-direction"></a>1.flex-direction</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flex-diretion主要是用来调整主轴的方向的，默认是水平方向</span><br><span class="line"></span><br><span class="line">了解即可，一般来说，很少调整主轴的方向。</span><br><span class="line"></span><br><span class="line">属性：</span><br><span class="line">row：主轴方向为水平向右</span><br><span class="line">column：主轴方向为竖直向下</span><br><span class="line">row-reverse:主轴方向为水平向左</span><br><span class="line">column-reverse:主轴方向是竖直向上。</span><br></pre></td></tr></table></figure>
<h2 id="2-justify-content-重点"><a href="#2-justify-content-重点" class="headerlink" title="2.justify-content(重点)"></a>2.justify-content(重点)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">justify-content主要用来设置主轴方向的对齐方式 ，可选的值有：</span><br><span class="line"></span><br><span class="line">flex-start:     弹性盒子元素将向起始位置对齐</span><br><span class="line">flex-end:       弹性盒子元素将向结束位置对齐。</span><br><span class="line">center:         弹性盒子元素将向行中间位置对齐</span><br><span class="line">space-around:   弹性盒子元素会平均地分布在行里</span><br><span class="line">space-between:  第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的。</span><br></pre></td></tr></table></figure>
<h2 id="3-align-items-重点"><a href="#3-align-items-重点" class="headerlink" title="3.align-items(重点)"></a>3.align-items(重点)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">align-items用于调整侧轴的对其方式 ，可选的值有：</span><br><span class="line"></span><br><span class="line">flex-start： 元素在侧轴的起始位置对其。 </span><br><span class="line">flex-end： 元素在侧轴的结束位置对其。</span><br><span class="line">center： 元素在侧轴上居中对其。</span><br><span class="line">stretch： 元素的高度会被拉伸到最大（不能给死高度）。</span><br></pre></td></tr></table></figure>
<h2 id="4-flex-wrap"><a href="#4-flex-wrap" class="headerlink" title="4.flex-wrap"></a>4.flex-wrap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap属性控制flex容器是单行或者多行,默认不换行</span><br><span class="line"></span><br><span class="line">nowrap： 不换行（默认），会压缩子盒子的宽度。</span><br><span class="line">wrap： 当宽度不够的时候，会换行。</span><br></pre></td></tr></table></figure>
<h2 id="5-align-content"><a href="#5-align-content" class="headerlink" title="5.align-content"></a>5.align-content</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">align-content用来设置多行的flex容器的排列方式。</span><br><span class="line"></span><br><span class="line">flex-start： 各行向侧轴的起始位置堆叠。 </span><br><span class="line">flex-end： 各行向弹性盒容器的结束位置堆叠。</span><br><span class="line">center： 各行向弹性盒容器的中间位置堆叠。</span><br><span class="line">space-between： 各行在侧轴中平均分布。 </span><br><span class="line">space-around： 第一行贴上边，最后一个行贴下边,其他行在弹性盒容器中平均分布。 </span><br><span class="line">stretch：拉伸，不设置高度的情况下。</span><br><span class="line"></span><br><span class="line">align-items与align-content的区别</span><br><span class="line"></span><br><span class="line">lign-items调整的是侧轴的对其方式，不换行一般用align-items</span><br><span class="line">align-content:必须是多行才生效，如果单行</span><br></pre></td></tr></table></figure>
<h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上述讲的属性都是给父盒子设置的，接下来的几个属性是给子盒子设置的。 </span><br><span class="line"></span><br><span class="line">flex属性用来设置子盒子如何分配主轴空间，单位是数值</span><br></pre></td></tr></table></figure>
<h3 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</span><br></pre></td></tr></table></figure>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">align-self也是用于设置在侧轴的位置，但是align-self给子元素设置，优先级比align-items的优先级高</span><br><span class="line">取值与align-items的取值一样。</span><br></pre></td></tr></table></figure>
<h1 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">什么是响应式布局</span><br><span class="line">响应式布局（respond layout）是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端（手机、平板、pc电脑、手表） ——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。</span><br><span class="line"></span><br><span class="line">为什么要有响应式布局？ </span><br><span class="line"></span><br><span class="line">- 在移动互联日益成熟的时候，在PC端开发的网页已经无法满足移动设备的要求。</span><br><span class="line">- 通常的做法是针对移动端单独做一套特定的版本。</span><br><span class="line">- 如果终端越来越多，那么需要开发的版本就会越来越多（大屏设备的普及）</span><br><span class="line">- 响应式布局 ：一个网站能够兼容多个终端（节约开发成本）</span><br></pre></td></tr></table></figure>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">面对不同分辨率设备灵活性强</span><br><span class="line"></span><br><span class="line">能够快捷解决多设备显示适应问题</span><br></pre></td></tr></table></figure>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">兼容各种设备工作量大，效率低下</span><br><span class="line"></span><br><span class="line">代码累赘，会出现隐藏无用的元素，加载时间加长</span><br><span class="line"></span><br><span class="line">其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</span><br><span class="line"></span><br><span class="line">一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</span><br></pre></td></tr></table></figure>
<h2 id="响应式开发与移动web开发的比较"><a href="#响应式开发与移动web开发的比较" class="headerlink" title="响应式开发与移动web开发的比较"></a>响应式开发与移动web开发的比较</h2><h3 id="web开发："><a href="#web开发：" class="headerlink" title="web开发："></a>web开发：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">引用场景	一般已经有了PC端网站，只需要端独开发移动端网站即可	针对一些新建网站，并且要求适配移动端</span><br><span class="line">开发  	针对性强，开发效率高                	        </span><br><span class="line">适配  	只能适配移动端或者PC端，pad上体验比较差           </span><br><span class="line">效率  	代码简介，加载快</span><br></pre></td></tr></table></figure>
<h3 id="响应式开发-："><a href="#响应式开发-：" class="headerlink" title="响应式开发 ："></a>响应式开发 ：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">引用场景        移动web开发+pc开发      </span><br><span class="line">开发            兼容各种终端，效率低</span><br><span class="line">适配            可以适配各种终端</span><br><span class="line">效率            代码相对复杂，加载慢</span><br></pre></td></tr></table></figure>
<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">媒体查询（Media Query）是CSS3提出来的一个新的属性，通过媒体查询可以查询到screen的宽度，从而指定某个宽度区间的网页布局。</span><br><span class="line"></span><br><span class="line">设备分类</span><br><span class="line"></span><br><span class="line">分类        宽度范围 </span><br><span class="line">大屏设备 	&gt;1200px     </span><br><span class="line">中屏设备 	992px~1200px</span><br><span class="line">小屏设备 	768px~992px </span><br><span class="line">超小屏设备	&lt; 768px</span><br></pre></td></tr></table></figure>
<h3 id="媒体查询的使用"><a href="#媒体查询的使用" class="headerlink" title="媒体查询的使用"></a>媒体查询的使用</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and 条件 &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*条件的写法*/</span></span><br><span class="line"><span class="comment">/*min-width:只要屏幕宽度超过这个值的设备样式就能生效*/</span></span><br><span class="line"><span class="comment">/*max-width:只要屏幕宽度小于这个值的设备样式就能生效*/</span></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1170px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">992px</span>) and (max-width: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">970px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">768px</span>) and (max-width: <span class="number">992px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">750px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>弊端：现在只有一个div，要做一套响应式布局，就需要如此多的代码，非常的麻烦，因此我们会更多的借助一些响应式的框架，比如bootstrap。</p>
<h2 id="bootstrap框架"><a href="#bootstrap框架" class="headerlink" title="bootstrap框架"></a>bootstrap框架</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。</span><br></pre></td></tr></table></figure>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul>
<li>组件简洁大方、代码规范精简、界面自定义性强。</li>
<li>Bootstrap是基于HTML5和CSS3开发的，它在jQuery的基础上进行了更为个性化和人性化的完善，形成一套自己独有的网站风格，并兼容大部分jQuery插件。</li>
<li>Bootstrap中包含了丰富的Web组件，根据这些组件，可以快速的搭建一个漂亮、功能完备的网站。</li>
</ul>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>有自己的生态圈，不断的更新迭代</li>
<li>提供了一套简洁、直观、强悍的组件</li>
<li>标准化的HTML+CSS编码规范</li>
<li>让开发更简单，提高了开发效率。</li>
<li>扩展性强，虽然界面组件样式已经定义好了，我们还可以自定义，修改默认样式。</li>
</ul>
<h3 id="版本："><a href="#版本：" class="headerlink" title="版本："></a>版本：</h3><ul>
<li>2.x.x 停止维护<ul>
<li>优点：兼容性好</li>
<li>缺点：代码不够简洁、功能不够完善</li>
</ul>
</li>
<li>3.x.x 目前使用最多<ul>
<li>优点：稳定，偏向于开发响应式布局，移动设备优先的WEB项目</li>
<li>缺点：放弃了IE67，对IE8支持但是界面效果不友好</li>
</ul>
</li>
<li>4.x.x 阶段</li>
</ul>
<h3 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>bootstrap基本模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!--引入bootstrap的核心样式文件--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"lib/bootstrap/css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，世界！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--bootstrap依赖与jquery，因此需要在bootstrap之前引入jquery文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/jquery/jquery-1.12.4.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入bootstrap的核心js文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"lib/bootstrap/js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h2><h3 id="container容器"><a href="#container容器" class="headerlink" title="container容器"></a>container容器</h3><p>Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器。默认带了15px的padding值。</p>
<p>.container 类用于固定宽度并支持响应式布局的容器。<br>.container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。</p>
<h4 id="这两种-容器类不能互相嵌套。"><a href="#这两种-容器类不能互相嵌套。" class="headerlink" title="这两种 容器类不能互相嵌套。"></a>这两种 容器类不能互相嵌套。</h4><h2 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h2><p>栅格系统，也叫网格系统</p>
<ul>
<li>.row用于抵消.container容器的15px的padding值</li>
<li>可以在.row中嵌套column</li>
</ul>
<p>栅格系统常用类（总共12列）<br>.col-xs-xx</p>
<p>.col-xs-6</p>
<p>在超小屏幕（及以上）生效</p>
<p>.col-sm-xx</p>
<p>.col-sm-6</p>
<p>在小屏幕（及以上）生效</p>
<p>.col-md-xx</p>
<p>.col-md-6</p>
<p>在中屏幕（及以上）生效</p>
<p>.col-lg-xx</p>
<p>.col-lg-3</p>
<p>在大屏幕及生效，占1/4</p>
<p>.col-lg-xx</p>
<p>.col-lg-4</p>
<p>在大屏幕及生效，占1/3</p>
<p>.col-lg-xx</p>
<p>.col-lg-5</p>
<p>在大屏幕及生效，占1/2</p>
<h1 id="倒计时的总结思路"><a href="#倒计时的总结思路" class="headerlink" title="倒计时的总结思路"></a>倒计时的总结思路</h1><p>步骤：</p>
<p>1.创建一个目标时间，并获取它的时间毫秒数</p>
<p>2.创建一个现在时间，并获取毫秒数</p>
<p>3.用目标时间减去现在的时间就可得出还有多长时间到达目标时间</p>
<p>4.用getHours，getMinutes,还有getSeconds分别获取它(结果)的时分秒</p>
<p>5.将结果显示在页面当中，并将小时单位减去8，因为电脑的单位需要换算</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"></span><br><span class="line">setInterval(timer, <span class="number">900</span>);</span><br><span class="line">        <span class="comment">//创建一个时间函数</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//获取目标元素，为存放时间对象做准备</span></span><br><span class="line">            <span class="keyword">var</span> timer = <span class="built_in">document</span>.getElementById(<span class="string">'timer'</span>).getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line">            <span class="comment">//创建一个目标时间</span></span><br><span class="line">            <span class="keyword">var</span> clck = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2019</span>,<span class="number">3</span>,<span class="number">25</span>,<span class="number">14</span>,<span class="number">00</span>,<span class="number">00</span>); </span><br><span class="line">            <span class="comment">//获取现在的时间</span></span><br><span class="line">            <span class="keyword">var</span> nowClck = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            <span class="comment">//创建一个变量用来存储目标时间减去现在的时间</span></span><br><span class="line">            <span class="keyword">var</span> nows = <span class="keyword">new</span> <span class="built_in">Date</span>(clck.getTime() - nowClck.getTime());</span><br><span class="line">            <span class="comment">//创建三个变量用来存储比较后的时，分，秒</span></span><br><span class="line">            <span class="keyword">var</span> ch, cm, cs;</span><br><span class="line">            <span class="comment">//获取nows的时分秒</span></span><br><span class="line">            cs = nows.getSeconds();</span><br><span class="line">            cm = nows.getMinutes();</span><br><span class="line">            ch = nows.getHours()<span class="number">-8</span>;</span><br><span class="line">            <span class="comment">//判断这个时间是否小于10，如果小于10在前面添加一个0</span></span><br><span class="line">            ch&lt;<span class="number">10</span>?ch=<span class="string">'0'</span>+ch:ch;</span><br><span class="line">            cm&lt;<span class="number">10</span>?cm=<span class="string">'0'</span>+cm:cm;</span><br><span class="line">            cs&lt;<span class="number">10</span>?cs=<span class="string">'0'</span>+cs:cs;</span><br><span class="line">            <span class="comment">//将时分秒输出到页面上</span></span><br><span class="line">            timer[<span class="number">0</span>].innerText =ch;</span><br><span class="line">            timer[<span class="number">1</span>].innerText =cm;</span><br><span class="line">            timer[<span class="number">2</span>].innerText =cs;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>​    时间不能倒走，但是可以通过获取时间差的方式来实现倒计时，注意在毫秒计算的过程中不要有强迫症</p>
<p>向下取整，否则在单位换算的过程中会导致underfind，setinterval方法的刷新时间可以稍稍比一秒稍快一点</p>
<p>这样的时间会看起来更加精准。</p>
<h1 id="滚动轮播图的总结思考"><a href="#滚动轮播图的总结思考" class="headerlink" title="滚动轮播图的总结思考"></a>滚动轮播图的总结思考</h1><p>思路：</p>
<p>​    1.先创建一个大的盒子作为视觉区，然后里面放上一个列表标签ul，ul的宽度是li的宽度和，</p>
<p>然后让li浮动起来，大盒子overflow：hidden，将超出的部分进行隐藏。</p>
<p>​    2.用js获取目标的元素，通过改变ul的marginleft的值来进行偏移，并且在刚好一张图片的位置下</p>
<p>暂停一秒，在图片结束的时候立刻从头开始，并创建一个时钟，控制轮播。</p>
<p>步骤： </p>
<p>​    1.获取盒子元素</p>
<p>​    2.创建一个变量并给目标父盒子初始化样式。</p>
<p>​    3.创建一个函数作为程序的主线程，里面放所有需要运行的函数。</p>
<p>​    4.添加判断条件</p>
<p>​    5.添加时钟事件</p>
<p>代码如下：</p>
<p>​    </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//banner 轮播图的部分</span></span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">banner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">//获取目标元素的子元素li</span></span><br><span class="line">           <span class="keyword">var</span> lst = <span class="built_in">document</span>.getElementById(<span class="string">'list'</span>).getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line">           <span class="keyword">var</span> left = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">var</span> timer;</span><br><span class="line">           <span class="comment">//初始化marginleft的值与单位</span></span><br><span class="line">           list.style.marginLeft = left + <span class="string">'%'</span>;</span><br><span class="line">           <span class="comment">//创建一个时钟  每两秒运行一次run（）；</span></span><br><span class="line">           timer = setTimeout(run, <span class="number">2000</span>);</span><br><span class="line">           <span class="comment">//创建一个run()函数作为整个banner 的主线程，控制整个banner的行为</span></span><br><span class="line">           <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">               <span class="comment">//如果这个left的值小于-700，那么left值为0，并且清除名字叫timer的时钟</span></span><br><span class="line">               <span class="keyword">if</span> (left &lt; <span class="number">-700</span>) &#123;</span><br><span class="line">                   left = <span class="number">0</span>;</span><br><span class="line">                   clearTimeout(timer);</span><br><span class="line">               &#125;</span><br><span class="line">               change();</span><br><span class="line">               timer = setTimeout(run, <span class="number">2000</span>);</span><br><span class="line">               <span class="comment">//设置left的偏移值，每执行一次run() 函数，就减少100</span></span><br><span class="line">               left -= <span class="number">100</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//这个函数是为了方便调用单位</span></span><br><span class="line">           <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">               list.style.marginLeft = left + <span class="string">'%'</span>;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>​    </p>
<p>思路总结：</p>
<p>​    滚动式的轮播在网上有很多种的版本，但是原理是一样通过改变marginleft的值来实现滚动的，这里我尝试了用百分比的方式布局，并通过改变marginleft的百分比来进行滚动，相比改变具体的值更加简便和适用移动端。</p>
<h1 id="移动端常用的布局优缺点"><a href="#移动端常用的布局优缺点" class="headerlink" title="移动端常用的布局优缺点"></a>移动端常用的布局优缺点</h1><h5 id="1-流式布局"><a href="#1-流式布局" class="headerlink" title="1.流式布局"></a>1.流式布局</h5><p>​    特点：用px做单位，在用户缩放的时候一部分固定一部分自适应；</p>
<p>​    缺点： 不是等比例缩放，缩放的字体以及图标效果不是很理想，只有几个机型可以完美实现设计图；</p>
<h5 id="2-响应式布局"><a href="#2-响应式布局" class="headerlink" title="2.响应式布局"></a>2.响应式布局</h5><p>​    特点：用px做单位，适配移动端和pc端，能够完美的进行pc和移动端之间进行缩放</p>
<p>​    缩放：只能适配部分机型，开发过程过于复杂，难维护；</p>
<h5 id="3-flex布局（弹性盒子）"><a href="#3-flex布局（弹性盒子）" class="headerlink" title="3.flex布局（弹性盒子）"></a>3.flex布局（弹性盒子）</h5><p>​    特点：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/03/自己的笔记/" data-id="cju0mhfud0001b0q9pm4qtr5j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/04/03/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/03/自己的笔记/">自己的笔记</a>
          </li>
        
          <li>
            <a href="/2019/04/03/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>